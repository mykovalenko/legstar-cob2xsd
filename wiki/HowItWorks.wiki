#summary How it works.
#labels Phase-Requirements,Featured

=Overview=

legstar-cob2xsd is written in Java.

There are 3 ways you can use it:

 * [#Running_a_standalone_executable_jar Running a standalone executable jar]

 * [#Running_an_Apache_ANT_Task Running an Apache ANT Task]

 * [#Calling_the_API_from_your_own_Java_code Calling the API from your own Java code] 

Here we describe these 3 implementations with an emphasis on the API.

=Running a standalone executable jar=

This is the easiest way to invoke the utility.

The distribution comes with *run.sh* and *run.bat* files.

By default, run picks up COBOL source code from a folder called "cobol" and places the result in a folder called "schema".

The -h option lists all parameters that you might want to set.

The executable jar is called legstar-cob2xsd-x.y.z-exe.jar where x.y.z is the version number. It bundles all its dependencies so you can move it around as you please.

You invoke such an executable the classical way (run.sh is an example of such a call):
{{{
java -jar legstar-cob2xsd-x.y.z-exe.jar -i cobol -o schema
}}}

The input can be a folder, in which case all files from that folder are processed, or a file name.

The output is always a folder.

The XML Schema name is build by appending ".xsd" to the COBOL file name.

=Running an Apache ANT Task=

The distribution comes with a *build.xml* which shows how to invoke the ant task.

If you need to set additional parameters, all options from [http://www.legsem.com/legstar/legstar-cob2xsd/apidocs/com/legstar/cob2xsd/Cob2XsdContext.html Cob2XsdContext] are available.

The rule is that the ant property name does not need the initial "set" prefix and should start
with a lowercase character. So for instance:
{{{
setTargetNamespace becomes targetNamespace
}}}

Here is an example where target namespace is set and LegStar annotations are requested:
{{{
<target name="cob2xsd" depends="init">
    <cob2xsd targetDir="${xsd.dir}"
         targetNamespace="http://www.mycompany.com/test"
         addLegStarAnnotations="true">
        <fileset dir="${cobol.dir}">
            <include name="*.c*"/>
        </fileset>
    </cob2xsd>
</target>
}}}

=Calling the API from your own Java code=

The distribution lib folder contains the jars that you might need to add to your classpath.

legstar-cob2xsd-x.y.z.jar is the major one.

It contains 2 main packages:

|| * Package name* || * description* ||
|| com.legstar.cobol || Contains the recognizer logic ||
|| com.legstar.cob2xsd || Contains the XML Schema generation ||

This represents the separation of concern between recognizing and generation. We should be able to reuse the recognizing part to produce other formats (JSON Schema for instance).

There is more detail on the recognizer implementation in CobolStructureRecognizer and on the XML Schema generation in CobolStructureXsdGeneration.

There are only 2 classes you should care about as an API user and both are in the com.legstar.cob2xsd package:

|| * Class name* || * description* ||
|| [http://www.legsem.com/legstar/legstar-cob2xsd/apidocs/com/legstar/cob2xsd/Cob2XsdContext.html Cob2XsdContext] || Set of XML Schema generation options ||
|| [http://www.legsem.com/legstar/legstar-cob2xsd/apidocs/com/legstar/cob2xsd/CobolStructureToXsd.html CobolStructureToXsd] || Implements the main *translate* methods ||

This is a snippet of code that shows a typical use of these classes:
{{{
        try {
            Cob2XsdContext context = new Cob2XsdContext();
            context.setTargetNamespace("http://www.mycompany.com/test");
            CobolStructureToXsd cob2xsd = new CobolStructureToXsd(context);
            String xmlSchema = cob2xsd.translate("       01 A.\n           02 B PIC X.");
            System.out.println(xmlSchema);
        } catch (CobolStructureToXsdException e) {
            e.printStackTrace();
        }

}}}
